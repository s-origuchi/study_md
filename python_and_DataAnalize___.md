2.Python
====================================================
## 2.2 Python基礎
### 2.2.2 Python文法
仮想環境の起動
````
$python3 -m venv env  # "env"はフォルダ名 venv-testでもなんでも
$source env/bin/ativate
(env)$python -V
Python 3.6.6
````

### 2.2.3 標準ライブラリ
- reモジュール
正規表現を用いた探索に使用できる

````
import re  #正規表現用モジュール
prog = re.compile("(P(yth|l)|Z)o[pn]e?") #正規表現オブジェクトを作成
prog.search("Python") # matchする場合 Matchオブジェクトを返す

prog.search("Spam") //matchしない場合はNoneを返す
````

- logging モジュール
処理中のメッセージを出力する。printと違い、ログレベルを変えることができる

````
import logging

logging.basicConfig(
filename='example.log', #Logファイル名の指定
level=logging.INFO,     #Logレベルの指定
format="%(asctime)%s:%(levelname)s:%(message)s"
)
````

````
#各ログレベルで出力する
#上のbasicConfigでログレベルの指定をしているので
#Info以降の行しか出力されない
logging.debug("debugレベル")
logging.info("INFOレベル")
logging.warning("警告レベル")
logging.error("エラーレベル")
logging.critical("重大なエラー")
````

- datetimeモジュール
日付処理用

````
from datetime import datetime, date
datetime.now() #現在日時取得
date.today() #今日の日付取得
date.today() - date(2008, 12,3) #python3 リリースからの日数計算
datetime.now().isoformat() #ISO8601形式の文字列を取得
date.today().strftime('%Y年%m月%d日') #日付を文字列に変換
datetime.strptime(”2018年7月11日”, "%Y年%m月%d日")
````
- pickleモジュール
pythonのオブジェクトをファイルなどで読み書きできるように

````
#import pickleモジュール
In [12]: import pickle

In [14]: d= {"today":date.today(),
    ...:     "delta":date(2020,1,1) - date.today()}

In [15]: d
Out[15]: {'delta': datetime.timedelta(128), 'today': datetime.date(2019, 8, 26)}

In [16]: pickle.dumps(d)
Out[16]: b'\x80\x03}q\x00(X\x05\x00\x00\x00todayq\x01cdatetime\ndate\nq\x02C\x04\x07\xe3\x08\x1aq\x03\x85q\x04Rq\x05X\x05\x00\x00\x00deltaq\x06cdatetime\ntimedelta\nq\x07K\x80K\x00K\x00\x87q\x08Rq\tu.'

In [17]: with open("date.pkl", "wb") as f:
    ...:     pickle.dump(d,f)
    ...:

In [18]: with open("date.pkl", "rb") as f:
    ...:     new_d = pickle.load(f)
    ...:

In [19]: new_d
Out[19]: {'delta': datetime.timedelta(128), 'today': datetime.date(2019, 8, 26)}
````


- pathlibモジュール
ファイルパスを扱うモジュール

````
In [21]: from pathlib import Path

In [22]: p = Path()

In [23]: p
Out[23]: PosixPath('.')

In [26]: p = Path("/spam")
In [27]: p/ "ham" / "eggs.txt"  #演算子でパスを作成
Out[27]: PosixPath('/spam/ham/eggs.txt')

In [30]: p = Path("date.pkl") #前の項目で作ったファイル

In [31]: p.exists()
Out[31]: True

In [32]: p.is_dir()
Out[32]: False
````

2.3 Jupyter
--------------------------------

- 便利な機能
  - よく使われるマジックコマンド
  %timeit, %%timeit :コマンド実行時の時間を出力

  - コマンドラインの実行
  先頭に "!"をつけるとシェルコマンドを実行できます。

  - Notebookの保管
  NoteBookファイル自体は JSON形式で記述されています。
  Jupyter NotebookのファイルメニューからnotebookファイルをHTML, Markdownに変換できます。
  また、 pandocやLaTeXがインストールされていればPDFへ変換することも可能です。
  Notebookファイル自体の参照はJupyterNotebookを起動して確認の他に、
  Githubなどのリポジトリサービスも対応しています。

3.数学
=========================================
## 3.1  数式を読むための基礎知識
### 3.1.1 数式と記号
- ギリシャ文字
数式にはギリシャ文字を使うよ！！

- 集合
x ∈ S　　(xは集合Sに含まれる)
A = {1,2,3,4}
B = {2,4,6,8}

A ∩ B = {2, 4}             積集合
A ∪ B = {1,2,3,4,6,8}     和集合

- 数のまとまり
数のまとまりを表現するとき下記の2通り
X1,X2, ・・・・・・, Xn　　または　　Xn (i=1,2,...ｎ)

### 3.1.2 数学記号
- 足し算の繰り返し　∑
- 掛け算の繰り返し Π
- 特殊な定数  
  - π  (円周率)
  - e  (ネイピア数 (自然対数の底))

### 3.1.3 関数の基本
- 関数の書き方
  f(x) = x^2 + 1

- 特殊な関数
f(x) = {(0, x>1), (1,0≦ｘ≦1)、 (0、x<0)}

- 指数関数　　シグモイド関数
- 対数関数
- 三角関数
- 双曲線関数
## 3.2 線形代数
### 3.2.1 ベクトルとその演算
- ベクトルとは
  - ベクトル
- ベクトルの演算
  - スカラー (単なる一つの数字)
- ノルム (ベクトルの大きさ)
  - マンハッタン距離 (平面格子シミュげの距離 単純に各要素を足す)
  - ユークリッド距離 (一般的なやつ。　２乗して足して平方根)
- 内積
  - X・Y (内積 dotを使って表現)
  - 各要素の掛け算を足し合わせたもの
  X・Y = ∑xi yi = x1・y1 + x2・y2  ... xi・yi （結果はスカラ）
  内積を２つのベクトルの大きさ（スカラー）で割るよcosになる

## 3.2.2 行列
- 行列
  - 正方行列 （N×N）
  - 単位行列 （E) 対角が1
- 行列の演算 （足し算 引き算）
- 行列の掛け算
m×s行列と s×nの行列の掛け算は結果が m×nになる
逆に m×nの行列は （m×s） × （s×n）に分解できる可能性がある

## 3.3 基礎解析
### 3.3.1 微分と積分の意味
- 積分は面積
  積分する範囲が決まっている場合を **定積分**
  範囲を決めない場合、**不定積分**

- 微分は傾き
関数F(x)を微分して　f(x)を導いたとき、Fをfの **原子関数**、 fをFの **導関数と呼ぶ**
### 3.3.2 簡単な関数の微分と積分
- いろいろな関数の微分積分
  - f(x)=e^x -> f'(x) =e^x

  - （sin x）' = cos X
  - （cos x)' = -sin X

  - log X = 1/X
### 3.3.3 微分と関数の値
- 関数f(x)を微分してあるポイントを調べたとき、 マイナスならばxの増加に伴いf(x)は減少、
プラスならば増加という傾向がある。複雑な関数の場合、微分して傾向を調べることもある
### 偏微分
- 二元以上の関数を微分することも可。その場合、片方は固定と考える。

## 3.4 確率と統計
### 3.4.1 統計の基礎
大量のデータの全体の傾向を調べる。->統計学の基本
- 代表値
データの傾向を示す値。よく使われるものとして
  - 最小値(minimum) データ内の最も小さな値
  - 最大値(maximum) データ内の最も大きな値
  - 平均値(mean) 算術平均。よくある
  - 中央値(median) データを小さい順に並べて、ちょうど中央に来る値。最大と最小の中間ではない。もしデータの数が偶数で中央が値を刺さない場合、そこの両脇の値の平均を取る
    - 分位数 （特に四分位数）　データを小さい順に並べ、先頭から全体の1/4番目のものを第一四分い線。その後順に第二〜第三〜と続く。
  - 最頻値（mode) データの中で最も多かった値。（アンケートなら最も多い選択肢）

- ばらつきの指標 （散布度）
  - 四分位範囲（IQR) データの中央値に対するばらつきを考えるとき、重要な値
第三四分位数と第一四分位数の差
  - 分散・標準偏差
  - 度数分布表  区切り （最大値から最小値を等分する） その範囲内のデータ個数を数える

### 3.4.2 データの可視化
- ヒストグラム　度数分布表を棒グラフで表現
- 箱ひげ表  ロウソクチャートっぽい　最大最小の棒に箱が刺さっている感じ
  箱には中央に白線（中央値） 箱の上辺・下辺は第3四分位数・第1四分位数。
- 散布図

### 3.4.3 データとその関係性
- 相関係数
1種類のデータのばらつきを図る指標として、 **分散** があるが、2種類のデータがある場合共分散で見る。
相関係数は共分散の値を2つの変数の標準偏差で割った値　（-1 - 1）の範囲
  - xが増えたときにYも増える傾向 ・・・1に近い
  - xが増えたときにYは減る傾向 ・・・-1に近い
  - ｘとyが連動しない　・・・ 0に近い

- 3.4.4 確率
なんかむずいので飛ばす

4.ライブラリによる分析の実践
====================================
## 4.1 Numpy
### 4.1.2 Numpy でデータを扱う
- 一次元配列、二次元配列、データ型、変形、

````
In [2]: import numpy as np
In [3]: b = np.array([[1,2,3],[4,5,6]])
In [4]: b
Out[4]:
array([[1, 2, 3],
       [4, 5, 6]])
In [5]: b.shape
Out[5]: (2, 3)    #外から個数を数える。考えたら当たり前だけどさ。
In [6]: c = b.ravel()  # 浅いコピー & 1次元へ変換
In [7]: c
Out[7]: array([1, 2, 3, 4, 5, 6])
In [9]: b[1,2]=8
In [10]: c
Out[10]: array([1, 2, 3, 4, 5, 8])
In [11]: c = b.flatten()  # 深いコピー & 1次元へ変換
In [12]: b[1,2]=10
In [13]: c
Out[13]: array([1, 2, 3, 4, 5, 8])
In [15]: c.reshape(3,2)  #一次元配列の形状変化
Out[15]:
array([[1, 2],
       [3, 4],
       [5, 8]])
In [21]: c.dtype   #データ型を調べる
Out[21]: dtype('int64')
In [22]: d = np.array([[1,2,3],[4,5,6]], dtype=np.int16) #データ型を調べてarrayを作成
In [23]: d
Out[23]:
array([[1, 2, 3],
       [4, 5, 6]], dtype=int16)

In [25]: d.astype(np.float128)  #arrayのデータ変更と型変換
Out[25]:
array([[1., 2., 3.],
       [4., 5., 6.]], dtype=float128)

````

- インデックスとスライス

````
In [28]: d
Out[28]:
array([[1, 2, 3],
       [4, 5, 6]], dtype=int16)
In [29]: d[:,1]
Out[29]: array([2, 5], dtype=int16)
In [30]: d[1,:]
Out[30]: array([4, 5, 6], dtype=int16)
In [31]: d[-1,:]
Out[31]: array([4, 5, 6], dtype=int16)
In [32]: d[:,-1]  #負のインデックス
Out[32]: array([3, 6], dtype=int16)  
In [33]: d[0,1:]
Out[33]: array([2, 3], dtype=int16)
In [34]: d[:,1:]  #スライス　ndarrayだとこれの結果も参照なので値代入に注意。
Out[34]:
array([[2, 3],
       [5, 6]], dtype=int16)
````

- 数列を作成

````
In [35]: np.arange(10)
Out[35]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
In [36]: np.arange(1,11)
Out[36]: array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
In [38]: np.arange(1,11,2)
Out[38]: array([1, 3, 5, 7, 9])
````

- 乱数

````
In [40]: f=np.random.random((3,2))  # 引数1個 （タプルで2つ）
In [41]: f
Out[41]:
array([[0.8770089 , 0.19641978],
       [0.69277314, 0.22737584],
       [0.75638054, 0.42139396]])

In [42]: np.random.randint(1,10)
Out[42]: 7

In [43]: np.random.randint(1,10,(3,2))
Out[43]:
array([[8, 8],
       [7, 3],
       [9, 4]])
]In [44]: np.random.uniform(size=(2,3)) #一様分布でのランダム
Out[44]:
array([[0.71510906, 0.34418506, 0.15690834],
       [0.38564315, 0.33680087, 0.55404277]])

In [45]: np.random.randn(4,2) #標準正規分布 （平均0 分散1 標準偏差1）
Out[45]:
array([[-1.97734945,  1.34331289],
       [ 0.5465015 ,  0.15129345],
       [ 1.41524939, -0.53147   ],
       [ 0.5386341 ,  1.33978623]])
In [46]: np.random.normal(loc=0, scale=2, size=10) #(loc:平均、 scale=標準偏差, size:個数 )
Out[46]:
array([-0.8354859 ,  2.08461587, -1.35618927, -1.88553292, -0.91594883,
       -0.04666615,  2.30290412,  1.04539503, -1.05818342, -3.13530935])

````

- 要素が同じ配列の作成

````
In [51]: np.zeros(20)  #要素の値が0な配列
Out[51]:
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0.])
In [52]: np.zeros((2,10)) #タプルを使えば多次元を作成可
Out[52]:
array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])
In [53]: np.ones((4,5))  #要素の値が１な配列
Out[53]:
array([[1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.]])
In [54]: np.full((2,5),np.pi) # 任意の値で配列作成。同様にタプルで多次元
Out[54]:
array([[3.14159265, 3.14159265, 3.14159265, 3.14159265, 3.14159265],
       [3.14159265, 3.14159265, 3.14159265, 3.14159265, 3.14159265]])
In [55]: np.nan    #欠損値用のデータ
Out[55]: nan
````

- 範囲指定で均等割データ作成
