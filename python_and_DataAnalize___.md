2.Python
====================================================
## 2.2 Python基礎
### 2.2.2 Python文法
仮想環境の起動
````
$python3 -m venv env  # "env"はフォルダ名 venv-testでもなんでも
$source env/bin/ativate
(env)$python -V
Python 3.6.6
````

### 2.2.3 標準ライブラリ
- reモジュール
正規表現を用いた探索に使用できる

````
import re  #正規表現用モジュール
prog = re.compile("(P(yth|l)|Z)o[pn]e?") #正規表現オブジェクトを作成
prog.search("Python") # matchする場合 Matchオブジェクトを返す

prog.search("Spam") //matchしない場合はNoneを返す
````

- logging モジュール
処理中のメッセージを出力する。printと違い、ログレベルを変えることができる

````
import logging

logging.basicConfig(
filename='example.log', #Logファイル名の指定
level=logging.INFO,     #Logレベルの指定
format="%(asctime)%s:%(levelname)s:%(message)s"
)
````

````
#各ログレベルで出力する
#上のbasicConfigでログレベルの指定をしているので
#Info以降の行しか出力されない
logging.debug("debugレベル")
logging.info("INFOレベル")
logging.warning("警告レベル")
logging.error("エラーレベル")
logging.critical("重大なエラー")
````

- datetimeモジュール
日付処理用

````
datetime.now() #現在日時取得
from datetime import datetime, date
date.today() #今日の日付取得
date.today() - date(2008, 12,3) #python3 リリースからの日数計算
datetime.now().isoformat() #ISO8601形式の文字列を取得
date.today().strftime('%Y年%m月%d日') #日付を文字列に変換
datetime.strptime(”2018年7月11日”, "%Y年%m月%d日")
````
- pickleモジュール
pythonのオブジェクトをファイルなどで読み書きできるように

````
#import pickleモジュール
In [12]: import pickle

In [14]: d= {"today":date.today(),
    ...:     "delta":date(2020,1,1) - date.today()}

In [15]: d
Out[15]: {'delta': datetime.timedelta(128), 'today': datetime.date(2019, 8, 26)}

In [16]: pickle.dumps(d)
Out[16]: b'\x80\x03}q\x00(X\x05\x00\x00\x00todayq\x01cdatetime\ndate\nq\x02C\x04\x07\xe3\x08\x1aq\x03\x85q\x04Rq\x05X\x05\x00\x00\x00deltaq\x06cdatetime\ntimedelta\nq\x07K\x80K\x00K\x00\x87q\x08Rq\tu.'

In [17]: with open("date.pkl", "wb") as f:
    ...:     pickle.dump(d,f)
    ...:

In [18]: with open("date.pkl", "rb") as f:
    ...:     new_d = pickle.load(f)
    ...:

In [19]: new_d
Out[19]: {'delta': datetime.timedelta(128), 'today': datetime.date(2019, 8, 26)}
````


- pathlibモジュール
ファイルパスを扱うモジュール

````
In [21]: from pathlib import Path

In [22]: p = Path()

In [23]: p
Out[23]: PosixPath('.')

In [26]: p = Path("/spam")
In [27]: p/ "ham" / "eggs.txt"  #演算子でパスを作成
Out[27]: PosixPath('/spam/ham/eggs.txt')

In [30]: p = Path("date.pkl") #前の項目で作ったファイル

In [31]: p.exists()
Out[31]: True

In [32]: p.is_dir()
Out[32]: False
````

2.3 Jupyter
--------------------------------

- 便利な機能
  - よく使われるマジックコマンド
  %timeit, %%timeit :コマンド実行時の時間を出力

  - コマンドラインの実行
  先頭に "!"をつけるとシェルコマンドを実行できます。

  - Notebookの保管
  NoteBookファイル自体は JSON形式で記述されています。
  Jupyter NotebookのファイルメニューからnotebookファイルをHTML, Markdownに変換できます。
  また、 pandocやLaTeXがインストールされていればPDFへ変換することも可能です。
  Notebookファイル自体の参照はJupyterNotebookを起動して確認の他に、
  Githubなどのリポジトリサービスも対応しています。

3.数学
=========================================
## 3.1  数式を読むための基礎知識
### 3.1.1 数式と記号
- ギリシャ文字
数式にはギリシャ文字を使うよ！！

- 集合
x ∈ S　　(xは集合Sに含まれる)
A = {1,2,3,4}
B = {2,4,6,8}

A ∩ B = {2, 4}             積集合
A ∪ B = {1,2,3,4,6,8}     和集合

- 数のまとまり
数のまとまりを表現するとき下記の2通り
X1,X2, ・・・・・・, Xn　　または　　Xn (i=1,2,...ｎ)

### 3.1.2 数学記号
- 足し算の繰り返し　∑
- 掛け算の繰り返し Π
- 特殊な定数  
  - π  (円周率)
  - e  (ネイピア数 (自然対数の底))

### 3.1.3 関数の基本
- 関数の書き方
  f(x) = x^2 + 1

- 特殊な関数
f(x) = {(0, x>1), (1,0≦ｘ≦1)、 (0、x<0)}

- 指数関数　　シグモイド関数
- 対数関数
- 三角関数
- 双曲線関数
## 3.2 線形代数
### 3.2.1 ベクトルとその演算
- ベクトルとは
  - ベクトル
- ベクトルの演算
  - スカラー (単なる一つの数字)
- ノルム (ベクトルの大きさ)
  - マンハッタン距離 (平面格子シミュげの距離 単純に各要素を足す)
  - ユークリッド距離 (一般的なやつ。　２乗して足して平方根)
- 内積
  - X・Y (内積 dotを使って表現)
  - 各要素の掛け算を足し合わせたもの
  X・Y = ∑xi yi = x1・y1 + x2・y2  ... xi・yi （結果はスカラ）
  内積を２つのベクトルの大きさ（スカラー）で割るよcosになる

## 3.2.2 行列
- 行列
  - 正方行列 （N×N）
  - 単位行列 （E) 対角が1
- 行列の演算 （足し算 引き算）
- 行列の掛け算
m×s行列と s×nの行列の掛け算は結果が m×nになる
逆に m×nの行列は （m×s） × （s×n）に分解できる可能性がある

## 3.3 基礎解析
### 3.3.1 微分と積分の意味
- 積分は面積
  積分する範囲が決まっている場合を **定積分**
  範囲を決めない場合、**不定積分**

- 微分は傾き
関数F(x)を微分して　f(x)を導いたとき、Fをfの **原子関数**、 fをFの **導関数と呼ぶ**
### 3.3.2 簡単な関数の微分と積分
- いろいろな関数の微分積分
  - f(x)=e^x -> f'(x) =e^x

  - （sin x）' = cos X
  - （cos x)' = -sin X

  - log X = 1/X
### 3.3.3 微分と関数の値
- 関数f(x)を微分してあるポイントを調べたとき、 マイナスならばxの増加に伴いf(x)は減少、
プラスならば増加という傾向がある。複雑な関数の場合、微分して傾向を調べることもある
### 偏微分
- 二元以上の関数を微分することも可。その場合、片方は固定と考える。

## 3.4 確率と統計
### 3.4.1 統計の基礎
大量のデータの全体の傾向を調べる。->統計学の基本
- 代表値
データの傾向を示す値。よく使われるものとして
  - 最小値(minimum) データ内の最も小さな値
  - 最大値(maximum) データ内の最も大きな値
  - 平均値(mean) 算術平均。よくある
  - 中央値(median) データを小さい順に並べて、ちょうど中央に来る値。最大と最小の中間ではない。もしデータの数が偶数で中央が値を刺さない場合、そこの両脇の値の平均を取る
    - 分位数 （特に四分位数）　データを小さい順に並べ、先頭から全体の1/4番目のものを第一四分い線。その後順に第二〜第三〜と続く。
  - 最頻値（mode) データの中で最も多かった値。（アンケートなら最も多い選択肢）

- ばらつきの指標 （散布度）
  - 四分位範囲（IQR) データの中央値に対するばらつきを考えるとき、重要な値
第三四分位数と第一四分位数の差
  - 分散・標準偏差
  - 度数分布表  区切り （最大値から最小値を等分する） その範囲内のデータ個数を数える

### 3.4.2 データの可視化
- ヒストグラム　度数分布表を棒グラフで表現
- 箱ひげ表  ロウソクチャートっぽい　最大最小の棒に箱が刺さっている感じ
  箱には中央に白線（中央値） 箱の上辺・下辺は第3四分位数・第1四分位数。
- 散布図

### 3.4.3 データとその関係性
- 相関係数
1種類のデータのばらつきを図る指標として、 **分散** があるが、2種類のデータがある場合共分散で見る。
相関係数は共分散の値を2つの変数の標準偏差で割った値　（-1 - 1）の範囲
  - xが増えたときにYも増える傾向 ・・・1に近い
  - xが増えたときにYは減る傾向 ・・・-1に近い
  - ｘとyが連動しない　・・・ 0に近い

- 3.4.4 確率
なんかむずいので飛ばす

4.ライブラリによる分析の実践
====================================
## 4.1 Numpy
### 4.1.2 Numpy でデータを扱う
- 一次元配列、二次元配列、データ型、変形、

````
In [2]: import numpy as np
In [3]: b = np.array([[1,2,3],[4,5,6]])
In [4]: b
Out[4]:
array([[1, 2, 3],
       [4, 5, 6]])
In [5]: b.shape
Out[5]: (2, 3)    #外から個数を数える。考えたら当たり前だけどさ。
In [6]: c = b.ravel()  # 浅いコピー & 1次元へ変換
In [7]: c
Out[7]: array([1, 2, 3, 4, 5, 6])
In [9]: b[1,2]=8
In [10]: c
Out[10]: array([1, 2, 3, 4, 5, 8])
In [11]: c = b.flatten()  # 深いコピー & 1次元へ変換
In [12]: b[1,2]=10
In [13]: c
Out[13]: array([1, 2, 3, 4, 5, 8])
In [15]: c.reshape(3,2)  #一次元配列の形状変化
Out[15]:
array([[1, 2],
       [3, 4],
       [5, 8]])
In [21]: c.dtype   #データ型を調べる
Out[21]: dtype('int64')
In [22]: d = np.array([[1,2,3],[4,5,6]], dtype=np.int16) #データ型を調べてarrayを作成
In [23]: d
Out[23]:
array([[1, 2, 3],
       [4, 5, 6]], dtype=int16)

In [25]: d.astype(np.float128)  #arrayのデータ変更と型変換
Out[25]:
array([[1., 2., 3.],
       [4., 5., 6.]], dtype=float128)

````

- インデックスとスライス

````
In [28]: d
Out[28]:
array([[1, 2, 3],
       [4, 5, 6]], dtype=int16)
In [29]: d[:,1]
Out[29]: array([2, 5], dtype=int16)
In [30]: d[1,:]
Out[30]: array([4, 5, 6], dtype=int16)
In [31]: d[-1,:]
Out[31]: array([4, 5, 6], dtype=int16)
In [32]: d[:,-1]  #負のインデックス
Out[32]: array([3, 6], dtype=int16)  
In [33]: d[0,1:]
Out[33]: array([2, 3], dtype=int16)
In [34]: d[:,1:]  #スライス　ndarrayだとこれの結果も参照なので値代入に注意。
Out[34]:
array([[2, 3],
       [5, 6]], dtype=int16)
````

- 数列を作成

````
In [35]: np.arange(10)
Out[35]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
In [36]: np.arange(1,11)
Out[36]: array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])
In [38]: np.arange(1,11,2)
Out[38]: array([1, 3, 5, 7, 9])
````

- 乱数

````
In [40]: f=np.random.random((3,2))  # 引数1個 （タプルで2つ）
In [41]: f
Out[41]:
array([[0.8770089 , 0.19641978],
       [0.69277314, 0.22737584],
       [0.75638054, 0.42139396]])

In [42]: np.random.randint(1,10)
Out[42]: 7

In [43]: np.random.randint(1,10,(3,2))
Out[43]:
array([[8, 8],
       [7, 3],
       [9, 4]])
]In [44]: np.random.uniform(size=(2,3)) #一様分布でのランダム
Out[44]:
array([[0.71510906, 0.34418506, 0.15690834],
       [0.38564315, 0.33680087, 0.55404277]])

In [45]: np.random.randn(4,2) #標準正規分布 （平均0 分散1 標準偏差1）
Out[45]:
array([[-1.97734945,  1.34331289],
       [ 0.5465015 ,  0.15129345],
       [ 1.41524939, -0.53147   ],
       [ 0.5386341 ,  1.33978623]])
In [46]: np.random.normal(loc=0, scale=2, size=10) #(loc:平均、 scale=標準偏差, size:個数 )
Out[46]:
array([-0.8354859 ,  2.08461587, -1.35618927, -1.88553292, -0.91594883,
       -0.04666615,  2.30290412,  1.04539503, -1.05818342, -3.13530935])

````

- 要素が同じ配列の作成

````
In [51]: np.zeros(20)  #要素の値が0な配列
Out[51]:
array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0.])
In [52]: np.zeros((2,10)) #タプルを使えば多次元を作成可
Out[52]:
array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])
In [53]: np.ones((4,5))  #要素の値が１な配列
Out[53]:
array([[1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.]])
In [54]: np.full((2,5),np.pi) # 任意の値で配列作成。同様にタプルで多次元
Out[54]:
array([[3.14159265, 3.14159265, 3.14159265, 3.14159265, 3.14159265],
       [3.14159265, 3.14159265, 3.14159265, 3.14159265, 3.14159265]])
In [55]: np.nan    #欠損値用のデータ
Out[55]: nan
````

- 範囲指定で均等割データ作成

`````
In [1]: import numpy as np
In [2]: np.linspace(0,1,5) // 指定値間を５分割
Out[2]: array([0.  , 0.25, 0.5 , 0.75, 1.  ])
In [3]: np.linspace(0,np.pi, 21) //0度から１８０度まで２１分割
Out[3]:
array([0.        , 0.15707963, 0.31415927, 0.4712389 , 0.62831853,
       0.78539816, 0.9424778 , 1.09955743, 1.25663706, 1.41371669,
       1.57079633, 1.72787596, 1.88495559, 2.04203522, 2.19911486,
       2.35619449, 2.51327412, 2.67035376, 2.82743339, 2.98451302,
       3.14159265])
`````

- 要素間の差分

````
In [4]: I = np.array([2,2,6,1,3])
In [7]: np.diff(I)　# 各要素の前後の差を
Out[7]: array([ 0,  4, -5,  2])
`````

- 連結

````
In [15]: print(a , a1)
[1 4 5] [1 4 5]
In [16]: np.concatenate( (a,a1)) #引数はタプルで一つにまとめる
Out[16]: array([1, 4, 5, 1, 4, 5])
In [17]: np.concatenate( [a,a1]) #引数はリストでも行ける
Out[17]: array([1, 4, 5, 1, 4, 5])
In [18]: b = np.array([[1,2,8],[4,5,6]]) #二次元の例
In [19]: b1 = np.array([[10],[29]])
In [20]: np.concatenate([b,b1], axis=1) #columnを増やすのでaxisに１を設定
Out[20]:
array([[ 1,  2,  8, 10],
       [ 4,  5,  6, 29]])
In [21]: np.hstack([b,b1]) #同じことをhstackでもできる（横のみ）
Out[21]:
array([[ 1,  2,  8, 10],
       [ 4,  5,  6, 29]])
In [22]: b2 = [30,60, 45]
In [24]: b2 = np.array([30,60, 45])
In [25]: b3 = np.vstack([b,b2]) # vscakでも同じことを
In [26]: b3
Out[26]:
array([[ 1,  2,  8],
       [ 4,  5,  6],
       [30, 60, 45]])
````

- 分割

````
In [26]: b3
Out[26]:
array([[ 1,  2,  8],
       [ 4,  5,  6],
       [30, 60, 45]])
In [27]: first, second = np.hsplit(b3, [2]) # 方向に注意

In [28]: first
Out[28]:
array([[ 1,  2],
       [ 4,  5],
       [30, 60]])
In [29]: second
Out[29]:
array([[ 8],
       [ 6],
       [45]])
In [30]: first, second = np.vsplit(b3, [2])　# 方向に注意
In [31]: first
Out[31]:
array([[1, 2, 8],
       [4, 5, 6]])

In [33]: first1, second1= np.vsplit(b3, [2])
In [38]: first1
Out[38]:
array([[1, 2, 8],
       [4, 5, 6]])
In [39]: second1
Out[39]: array([[30, 60, 45]])

````

- 転置

`````
In [40]: ｂ
Out[40]:
array([[1, 2, 8],
       [4, 5, 6]])

In [41]: b.T
Out[41]:
array([[1, 4],
       [2, 5],
       [8, 6]])
`````

- 次元追加

````
In [42]: a
Out[42]: array([1, 4, 5])

In [43]: a[np.newaxis, :] #次元を追加
Out[43]: array([[1, 4, 5]])
In [45]: a[:,np.newaxis] #次元を追加
Out[45]:
array([[1],
       [4],
       [5]])
`````

- グリッドデータの生成

`````
#次元を追加

In [47]: m = np.arange(0,4)

In [48]: n = np.arange(4,7)

In [49]: xx,yy = np.meshgrid(m,n)

In [50]: xx
Out[50]:
array([[0, 1, 2, 3],
       [0, 1, 2, 3],
       [0, 1, 2, 3]])

In [51]: yy
Out[51]:
array([[4, 4, 4, 4],
       [5, 5, 5, 5],
       [6, 6, 6, 6]])
`````
### 4.1.3 NumPyの各機能
- 準備  （サンプルにする値）

````
In [52]: a = np.arange(3)
In [53]: b = np.arange(-3,3).reshape((2,3))
In [55]: c = np.arange(1,7).reshape((2,3))
In [56]: d = np.arange(6).reshape((3,2))
In [57]: e = np.linspace(-1,1,10)

````

- ユニバーサルファンクション
中の値一つ一つ出す制御を書かずに、NumPyの機能で各要素を関数に入れられる

`````
In [58]: b
Out[58]:
array([[-3, -2, -1],
       [ 0,  1,  2]])
In [59]: np.abs(b)  #中の要素をすべて絶対値に
Out[59]:
array([[3, 2, 1],
       [0, 1, 2]])
In [60]: b*2　　　　　#中の要素すべて×２にする
Out[60]:
array([[-6, -4, -2],
       [ 0,  2,  4]])
In [61]: np.sin(e)
Out[61]:
array([-0.84147098, -0.70169788, -0.52741539, -0.3271947 , -0.11088263,
       0.11088263,  0.3271947 ,  0.52741539,  0.70169788,  0.84147098])
In [62]: np.cos(e)
Out[62]:
array([0.54030231, 0.71247462, 0.84960756, 0.94495695, 0.99383351,
       0.99383351, 0.94495695, 0.84960756, 0.71247462, 0.54030231])
In [63]: np.log(e)
/usr/lib/python-exec/python3.6/ipython3:1: RuntimeWarning: invalid value encountered in log
  #!/usr/bin/python3.6
Out[63]:
array([        nan,         nan,         nan,         nan,         nan,
       -2.19722458, -1.09861229, -0.58778666, -0.25131443,  0.        ])
In [64]: np.log(a)
/usr/lib/python-exec/python3.6/ipython3:1: RuntimeWarning: divide by zero encountered in log
  #!/usr/bin/python3.6
Out[64]: array([      -inf, 0.        , 0.69314718])
In [65]: np.log10(e)
/usr/lib/python-exec/python3.6/ipython3:1: RuntimeWarning: invalid value encountered in log10
  #!/usr/bin/python3.6
Out[65]:
array([        nan,         nan,         nan,         nan,         nan,
       -0.95424251, -0.47712125, -0.25527251, -0.10914447,  0.        ])

In [66]: np.log10(c)
Out[66]:
array([[0.        , 0.30103   , 0.47712125],
       [0.60205999, 0.69897   , 0.77815125]])

`````

- ブロードキャスト
各要素を取り出す制御を書かずに、各要素に加減乗除の計算を行える
次元の違う行列でも計算可能

````````
In [67]: a
Out[67]: array([0, 1, 2])

In [68]: a + 10 #全要素に+１０
Out[68]: array([10, 11, 12])

In [69]: a,b
Out[69]:
(array([0, 1, 2]), array([[-3, -2, -1],
        [ 0,  1,  2]]))

In [70]: a + b #各行にaを加算
Out[70]:
array([[-3, -1,  1],
       [ 0,  2,  4]])

In [76]: a
Out[76]: array([0, 1, 2])
In [78]: a1 = a[:,np.newaxis]
In [79]: a1
Out[79]:
array([[0],
       [1],
       [2]])
In [80]: a + a1 (3×１行列と１×３行列の加算は３×３の行列になる)
Out[80]:
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])

`````````

- ドット積

````
In [86]: np.dot(b,a) # 行列の積
Out[86]: array([-4,  5])

In [87]: b@a
Out[87]: array([-4,  5])

````

- 判定
各要素を抜き出さずに、値を判定する

````
In [89]: a>1
Out[89]: array([False, False,  True])

In [90]: b<0
Out[90]:
array([[ True,  True,  True],
       [False, False, False]])
````

## 4.2 pandas
### 4.2.1 pandasの概要
- pandas とは
NumPyを基盤に **シリーズ（Series）** と **データフレーム（DataFrame）** というデータ型を提供。

````
In [1]: import pandas as pd
````

- Seriesとは
一次元データ。下記例ではすべて数字を入れたため、
データタイプはnp.int64

````
In [2]: ser = pd.Series([10,20,30,40])

In [3]: ser
Out[3]:
0    10
1    20
2    30
3    40
dtype: int64
````


- DataFrameとは
二次元のデータ。

````
In [4]: df = pd.DataFrame([[10,"a",True],
   ...:                   [20,"b",False],
   ...:                   [30,"c",False],
   ...:                   [40, "d", True]])

In [5]: df
Out[5]:
    0  1      2
0  10  a   True
1  20  b  False
2  30  c  False
3  40  d   True

````

- DataFrameの概要を見る

````
In [2]: import numpy as np

In [3]: df = pd.DataFrame(np.arange(100).reshape((25,4)))

In [4]: df.head()
Out[4]:
    0   1   2   3
0   0   1   2   3
1   4   5   6   7
2   8   9  10  11
3  12  13  14  15
4  16  17  18  19

In [6]: df.shape
Out[6]: (25, 4)
````

- インデックス名、カラム名
名前をつけよう

````
In [9]: df.index = ["01", "02", "03"] #後から加える場合
In [12]: df.columns = ["a", "b"]
In [13]: df
Out[13]:
    a  b
01  0  1
02  2  3
03  4  5

#データフレーム作成時にコラム・インデックスを指定する方法
In [5]: name_df = pd.DataFrame(np.arange(6).reshape((3,2)),
                               columns=["aa","BB"],
                               index=["1列目", "2列め", "3列目"])
In [6]: name_df
Out[6]:
     aa  BB
1列目   0   1
2列め   2   3
3列目   4   5

#辞書データを利用して開く方法
In [8]: pd.DataFrame({"A":[0,2,4] ,"B":[1,3,5]})
Out[8]:
   A  B
0  0  1
1  2  3
2  4  5

````

- Dataの抽出
pandas データFrameからデータを取り出す

````
In [13]: df = pd.DataFrame(np.arange(12).reshape((4,3)),columns=["aa","BB", "c"],index=["1列目", "2列め", "3列目", "4列目"])

In [14]: df
Out[14]:
     aa  BB   c
1列目   0   1   2
2列め   3   4   5
3列目   6   7   8
4列目   9  10  11

In [15]: df["aa"]　#取り出されるデータはSeriarl
Out[15]:
1列目    0
2列め    3
3列目    6
4列目    9
Name: aa, dtype: int64
In [19]: df
Out[19]:
     aa  BB   c
1列目   0   1   2
2列め   3   4   5
3列目   6   7   8
4列目   9  10  11

In [20]: df[["aa", "BB"]] #カラムをリスト型で指定
Out[20]:
     aa  BB
1列目   0   1
2列め   3   4
3列目   6   7
4列目   9  10

In [21]: df[["aa", "c"]]
Out[21]:
     aa   c
1列目   0   2
2列め   3   5
3列目   6   8
4列目   9  11

In [22]: df[:2] #インデックスを指定
Out[22]:
     aa  BB  c
1列目   0   1  2
2列め   3   4  5

````

抽出方法を直接ではなく、loc() または iloc（）を使用して抽出する

````
In [27]: df.loc[:,"aa"]
Out[27]:
1列目    0
2列め    3
3列目    6
4列目    9
Name: aa, dtype: int64

In [28]: df.iloc[1:,:2]
Out[28]:
     aa  BB
2列め   3   4
3列目   6   7
4列目   9  10
````

### 4.2.2 データの読み込み、書き込み

- データ読み込み:csvファイル
csvからデータを読むことができます。

````
In [34]: df = pd.read_csv("env-home/notebooks/data/201704health.csv", encoding="utf-8")

In [35]: df.head()
Out[35]:
           日付     歩数  摂取カロリー
0  2017-04-01   5439    2500
1  2017-04-02   2510    2300
2  2017-04-03  10238    1950
3  2017-04-04   8209    1850
4  2017-04-05   9434    1930
````

- データ読み込み：excelファイル

`````
In [34]: df = pd.read_csv("env-home/notebooks/data/201704health.csv", encoding="utf-8")

In [35]: df.head()
Out[35]:
           日付     歩数  摂取カロリー
0  2017-04-01   5439    2500
1  2017-04-02   2510    2300
2  2017-04-03  10238    1950
3  2017-04-04   8209    1850
4  2017-04-05   9434    1930
`````

- データ書き込み
csv、excel書き込みを両方試します。

````
In [53]: df.to_csv("~/test.csv")
In [54]: df.to_excel("~/test.xlsx")
````

データをそのまま保管するにはpickle形式があります

````
In [59]: df.to_pickle("~/test.pickle")

In [60]: df1 = pd.read_pickle("~/test.pickle")

In [61]: df1
Out[61]:
            日付     歩数  摂取カロリー
0   2017-04-01   5439    2500
1   2017-04-02   2510    2300
2   2017-04-03  10238    1950
3   2017-04-04   8209    1850
4   2017-04-05   9434    1930
5   2017-04-06   7593    1800
````

### 4.2.3 データの整形


- 条件で抽出

````
In [66]: df["歩数"] >= 10000
Out[66]:
0     False
1     False
2      True
3     False
---中略---
21    False
22    False
23    False
24    False
25    False
26    False
27    False
28    False
29    False
Name: 歩数, dtype: bool
````
戻り値はbool型のシリーズ

上の結果を利用して10000歩を超えている行を調べる

````
In [80]: df_selected = df[df["歩数"] >= 10000]

In [81]: df_selected
Out[81]:
            日付     歩数  摂取カロリー
2   2017-04-03  10238    1950
8   2017-04-09  12045    1950
12  2017-04-13  10287    1800
19  2017-04-20  15328    1800
20  2017-04-21  12849    1940
````

データ抽出にはqueryメソッドを使用する方法もある

```
In [84]: df.query("歩数>=10000 and 摂取カロリー <= 1800")
Out[84]:
            日付     歩数  摂取カロリー
12  2017-04-13  10287    1800
19  2017-04-20  15328    1800
```

日付が文字列のままになっている。これをdatetime型に変換したい
"date"カラムにapplyメソッドで変換したデータを保管する

``````
In [92]: df.loc[:,"日付"].apply(pd.to_datetime)
Out[92]:
0    2017-04-01
1    2017-04-02
2    2017-04-03
--<中略>--
27   2017-04-28
28   2017-04-29
29   2017-04-30
Name: 日付, dtype: datetime64[ns]
``````

applyメソッドを適用するとこんな感じでSeriesを出力する
差し込む場所を指定して代入することができる

``````
In [88]: df.loc[:,"date"] = df.loc[:,"日付"].apply(pd.to_datetime)

In [89]: df
Out[89]:
            日付     歩数  摂取カロリー       date
0   2017-04-01   5439    2500 2017-04-01
1   2017-04-02   2510    2300 2017-04-02
2   2017-04-03  10238    1950 2017-04-03
3   2017-04-04   8209    1850 2017-04-04
``````

- data型変換

摂取カロリーの形を変換する
``````
In [100]: df.loc[:,"摂取カロリー"] = df.loc[:,"摂取カロリー"].astype(np.float128)

In [103]: df.loc[:,"摂取カロリー"]
Out[103]:
0     2500.0
1     2300.0
2     1950.0
3     1850.0
--<中略>--
27    1850.0
28    2300.0
29    1950.0
Name: 摂取カロリー, dtype: float128
``````

indexを標準から"date"カラムに変更する

````
In [105]: df = df.set_index("date")

In [106]: df.head()
Out[106]:
                    日付     歩数  摂取カロリー
date                                 
2017-04-01  2017-04-01   5439  2500.0
2017-04-02  2017-04-02   2510  2300.0
2017-04-03  2017-04-03  10238  1950.0
2017-04-04  2017-04-04   8209  1850.0
2017-04-05  2017-04-05   9434  1930.0
````

- 並べ替え
歩数で並べ替え

````
In [108]: df.sort_values(by="歩数").head()
Out[108]:
                    日付    歩数  摂取カロリー
date                                
2017-04-02  2017-04-02  2510  2300.0
2017-04-23  2017-04-23  3890  1950.0
2017-04-22  2017-04-22  4029  2300.0
2017-04-30  2017-04-30  4093  1950.0
2017-04-08  2017-04-08  4873  2300.0
````

歩数で並べ替え(降順)

````
In [109]: df.sort_values(by="歩数", ascending=False).head()
Out[109]:
                    日付     歩数  摂取カロリー
date                                 
2017-04-20  2017-04-20  15328  1800.0
2017-04-21  2017-04-21  12849  1940.0
2017-04-09  2017-04-09  12045  1950.0
2017-04-13  2017-04-13  10287  1800.0
2017-04-03  2017-04-03  10238  1950.0
````

- 不要なカラムの削除

````
In [114]: df.drop("日付", axis=1).head()
Out[114]:
               歩数  摂取カロリー
date                     
2017-04-01   5439  2500.0
2017-04-02   2510  2300.0
2017-04-03  10238  1950.0
2017-04-04   8209  1850.0
2017-04-05   9434  1930.0
````

- 組み合わせデータの挿入

````
In [129]: (df.loc[:,"歩数"]/df.loc[:,"摂取カロリー"]).head()
Out[129]:
date
2017-04-01    2.175600
2017-04-02    1.091304
2017-04-03    5.250256
2017-04-04    4.437297
2017-04-05    4.888083
dtype: float128

In [130]: df.loc[:,"歩数/カロリー"] = df.loc[:,"歩数"]/df.loc[:,"摂取カロリー"]
In [132]: df.tail()
Out[132]:
              歩数  摂取カロリー   歩数/カロリー
date                              
2017-04-26  7492  1850.0  4.049730
2017-04-27  7203  1930.0  3.732124
2017-04-28  7302  1850.0  3.947027
2017-04-29  6033  2300.0  2.623043
2017-04-30  4093  1950.0  2.098974

````

applyと自作メソッドを使った組み合わせデータ挿入
````
In [135]: def exercise_judge(ex):
     ...:     if ex <= 3.0:
     ...:         return "Low"
     ...:     elif 3.0 <=ex<= 6.0:
     ...:         return "Mid"
     ...:     else:
     ...:         return "High"


In [141]: df.loc[:,"歩数/カロリー"].apply(exercise_judge).head()
Out[141]:
date
2017-04-01    Low
2017-04-02    Low
2017-04-03    Mid
2017-04-04    Mid
2017-04-05    Mid
Name: 歩数/カロリー, dtype: object

In [142]: df.loc[:,"運動指数"] = df.loc[:,"歩数/カロリー"].apply(exercise_judge)

In [143]: df.tail()
Out[143]:
              歩数  摂取カロリー   歩数/カロリー 運動指数
date                                   
2017-04-26  7492  1850.0  4.049730  Mid
2017-04-27  7203  1930.0  3.732124  Mid
2017-04-28  7302  1850.0  3.947027  Mid
2017-04-29  6033  2300.0  2.623043  Low
2017-04-30  4093  1950.0  2.098974  Low
````

- one-shot encoding

````
In [149]: df_moved = pd.get_dummies(df.loc[:,"運動指数"], prefix="運動")

In [150]: df_moved.head()
Out[150]:
            運動_High  運動_Low  運動_Mid
date                               
2017-04-01        0       1       0
2017-04-02        0       1       0
2017-04-03        0       0       1
2017-04-04        0       0       1
2017-04-05        0       0       1

````

### 4.2.4 時系列データ
